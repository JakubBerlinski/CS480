class shaderLoader {
	public:
		void load(string, string);
		void linker(GLuint);
	private:
		char *vf, *fs;
   		GLuint vertex_shader = glCreateShader(GL_VERTEX_SHADER);
    	GLuint fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
    	GLint shader_status;
};

void shaderLoader::linker(GLuint p1) {

}

void shaderLoader::load(string fvs, string ffs) {
	std::ifstream is1;
	std::ifstream is2;
	int length = 0;

	is1.open(fvs, std::ios::binary);
	is1.seekg(0, std::ios::end);
	length = is1.tellg();
	is1.seekg(0, std::ios::beg);
	*vs = new char[length];
	is1.read(ret, length);
	is1.close();

	is2.open(ffs, std::ios::binary);
	is2.seekg(0, std::ios::end);
	length = is2.tellg();
	is2.seekg(0, std::ios::beg);
	*fs = new char[length];
	is2.read(ret, length);
	is2.close();

    glShaderSource(vertex_shader, 1, &vs, NULL);
    glCompileShader(vertex_shader);
    glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &shader_status);
    if(!shader_status)
    {
        std::cerr << "[F] FAILED TO COMPILE VERTEX SHADER!" << std::endl;
        return false;
    }

    glShaderSource(fragment_shader, 1, &fs, NULL);
    glCompileShader(fragment_shader);
    glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &shader_status);
    if(!shader_status)
    {
        std::cerr << "[F] FAILED TO COMPILE FRAGMENT SHADER!" << std::endl;
        return false;
    }
}
